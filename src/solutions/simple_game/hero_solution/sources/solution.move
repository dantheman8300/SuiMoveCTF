// Special thanks to nick0ve for providing me the solution to this challenge

module hero_solution::solution {

  use std::hash;
  use std::vector;

  use game::hero::{Self, Hero};
  use game::adventure;
  use game::inventory;

  use sui::tx_context::TxContext;
  use sui::bcs;
  use sui::object;

  const ERR_HIGH_ARG_GREATER_THAN_LOW_ARG: u64 = 101;

  struct MyTxContext has drop {
    /// A `signer` wrapping the address of the user that signed the current transaction
    signer: address,
    /// Hash of the current transaction
    tx_hash: vector<u8>,
    /// The current epoch number.
    epoch: u64,
    /// Counter recording the number of fresh id's created while executing
    /// this transaction. Always 0 at the start of a transaction
    ids_created: u64
  }

  //===========================================================================
  // Automation to slay boars until the hero has enough xp to level up. Once
  // leveled up, the hero will slay boar kings until stamina is out. This
  // will most likely be enough to generate a Treasury Box
  //===========================================================================
  public entry fun level_up_hero(hero: &mut Hero, ctx: &mut TxContext) {
    // Get hero's starting experience
    let hero_xp: u64 = hero::experience(hero);

    // Slay boars in batch of tens until hero has xp >= 100
    while (hero_xp < 100) {
      // Check the hero has enough stamina to battle boar
      assert!(hero::stamina(hero) >= 1, 8);
      adventure::slay_boar(hero, ctx);
      hero_xp = hero::experience(hero); // Get hero's updated experience
    };

    // Level up hero once the hero has enough xp
    hero::level_up(hero);
    
    return
  }

  //===========================================================================
  // Function to slay the king while also exploiting the RNG to ensure we get
  // a treasury box
  //===========================================================================
  public entry fun slay_king(hero: &mut Hero, ctx: &mut TxContext) {
    let ctx_bytes = bcs::to_bytes(ctx);
    let mytx = get_mytx_from_bytes(ctx_bytes);

    let start = 4;
    let end = 1000;
    
    while (start < end) {
      let d100 = rangify(get_rand_ith(&mut mytx, start), 0, 100);
      if (d100 == 0) {
        advance_rng_count(ctx, start-4);
        adventure::slay_boar_king(hero, ctx);
        break
      };
      start = start + 1;
    };
  }

  //===========================================================================
  // Ensure that the flag will be generated by predicting the random number 
  // generator
  //===========================================================================
  public entry fun do_get_flag(box: inventory::TreasuryBox, ctx: &mut TxContext) {
    let ctx_bytes = bcs::to_bytes(ctx);
    let mytx = get_mytx_from_bytes(ctx_bytes);

    let start = 4;
    let end = 1000;
    
    while (start < end) {
      let d100 = rangify(get_rand_ith(&mut mytx, start), 0, 100); // Try the next local RNG

      if (d100 == 0) { // Random number is 0 (as desired)
        advance_rng_count(ctx, start); // Modify TxContext
        break
      };
      start = start + 1;
    };
    inventory::get_flag(box, ctx);
  }

  //===========================================================================
  // Build our own local TxContext from the data of the actual TxContext
  //
  // This function uses the bcs module to serialize and deserialize the 
  // TxContext data
  //===========================================================================
  fun get_mytx_from_bytes(bytes: vector<u8>): MyTxContext {
    let deserializer = bcs::new(bytes);
    let signer_address = bcs::peel_address(&mut deserializer);
    let tx_hash = bcs::peel_vec_u8(&mut deserializer);
    let epoch = bcs::peel_u64(&mut deserializer);
    let ids_created = bcs::peel_u64(&mut deserializer);
    
    MyTxContext {
        signer: signer_address,
        tx_hash,
        epoch,
        ids_created
    }
  }

  //===========================================================================
  // Apply a range to a given number
  //===========================================================================
  fun rangify(val: u64, low: u64, high: u64): u64 {
    (val % (high - low)) + low
  }

  //===========================================================================
  // Get random number based on our own local random number generator that is 
  // based off the challenge's RNG (random number generator)
  // 
  // Modifies the MyTxContext's ids_created to simulate the TxContext's 
  // ids_created
  // 
  // Returns the random number
  //===========================================================================
  fun get_rand_ith(mytx: &mut MyTxContext, i: u64): u64 {
    mytx.ids_created = i;
    let my_uid_bytes = get_slice(derive_id(mytx.tx_hash, i), 0, 20);
    let my_seed = seed(bcs::to_bytes(mytx), my_uid_bytes);
    let my_val = rand_u64_with_seed(my_seed);
    my_val
  }

  //===========================================================================
  // For the given count, advance the RNG that many rounds
  // 
  // This is to get the actual RNG to the state that we predicted will result
  // in the desired number
  //===========================================================================
  fun advance_rng_count(ctx: &mut TxContext, count: u64) {
    let i = 0;
    while (i < count) {
      advance_rng(ctx);
      i = i + 1;
    };
  }

  //===========================================================================
  // Iterate TxContext's ids_created by creating objects
  //===========================================================================
  fun advance_rng(ctx: &mut TxContext) {
    let uid = object::new(ctx);
    let _uid_bytes: vector<u8> = object::uid_to_bytes(&uid);
    object::delete(uid);
  }

  //===========================================================================
  // Local version of the RNG seed generator
  //===========================================================================
  fun seed(ctx_bytes: vector<u8>, uid_bytes: vector<u8>): vector<u8> {

    let info: vector<u8> = vector::empty<u8>();
    vector::append<u8>(&mut info, ctx_bytes);
    vector::append<u8>(&mut info, uid_bytes);

    let hash: vector<u8> = hash::sha3_256(info);
    hash
  }

  //===========================================================================
  // get a portion of a given vector
  //===========================================================================
  fun get_slice(blob: vector<u8>, start: u64, end: u64): vector<u8> {
    assert!(start <= end, 1337);
    let slice: vector<u8> = vector::empty<u8>();
    let i = start;
    while (i < end) {
      vector::push_back(&mut slice, *vector::borrow(&blob, i));
      i = i + 1;
    };
    slice
  }

  //===========================================================================
  // Local version of the derive_id() function
  //===========================================================================
  fun derive_id(tx_hash: vector<u8>, creation_num: u64): vector<u8> {
    let id: vector<u8> = vector::empty<u8>();
    vector::append<u8>(&mut id, tx_hash);
    vector::append<u8>(&mut id, bcs::to_bytes(&creation_num));
    let hash: vector<u8> = hash::sha3_256(id);
    hash
  }

  //===========================================================================
  // Local version of the RNG helper
  //===========================================================================
  fun bytes_to_u64(bytes: vector<u8>): u64 {
    let value = 0u64;
    let i = 0u64;
    while (i < 8) {
      value = value | ((*vector::borrow(&bytes, i) as u64) << ((8 * (7 - i)) as u8));
      i = i + 1;
    };
    return value
  }

  //===========================================================================
  // Local version of the RNG helper
  //
  // Generate a random u64
  //===========================================================================
  fun rand_u64_with_seed(_seed: vector<u8>): u64 {
    bytes_to_u64(_seed)
  }

  //===========================================================================
  // Local version of the RNG helper
  //
  // Generate a random integer range in [low, high).
  //===========================================================================
  fun rand_u64_range_with_seed(_seed: vector<u8>, low: u64, high: u64): u64 {
    assert!(high > low, ERR_HIGH_ARG_GREATER_THAN_LOW_ARG);
    let value = rand_u64_with_seed(_seed);
    (value % (high - low)) + low
  }

}